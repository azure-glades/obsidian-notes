---
number headings:
---
> Understand what happens behind the abstraction of memory allocation and deallocation.
> What goes behind the abstraction when we allocate memory, deallocate memory, how RAM is managed
> What the hell is virtual memory?

- Memory access should be quick and correct.
- Memory access has to be monitored to protect memory integrity (Like accessing memory that does not belong to you)

- CPU can only access memory directly from *Registers* and *Cache*. Processes are stored in RAM (memory), and these instructions are loaded sequentially in registers for execution
	- *Register* stores the immediate next set of instructions and stored output/input data.
		- Extremely fast -> Accessed within 1 clock cycle
	- *Cache* stores various environment variables and info that is regularly referred to by the process. It enables quick access of regularly used variables/info.
		- Faster than main memory
	- Range of an address space given to a process is specified using base-limit registers
	- A pair of _base_ and _limit_ registers define the logical address space for a process, acting as boundaries to separate memory for different processes in RAM. If a process exceeds its base-limit size, it is auto-aborted.
		- Ex: Base = 30040, Limit = 120900. The program can legally access addresses from 30040 to 420939
		- Attempt to access memory outside bounds causes an interrupt which usually terminates the program
		- This enforces *memory safety*, where a user program cannot modify the code/data-structure of other programs
			- Prevents unauthorized/dangerous execution of code.
	- The base-limit registers assigned to a process can only be changed by the OS, when it is operating in *kernel mode*.
		- Kernel mode operation allows the OS to load programs to memory, execute them, dump the core/call-stack, manage i/o operations and handle system calls.
	- When a process terminates or is moved out of memory, its cache is cleared and stored in the Process Control Block (PCB). This process, called _cache invalidation_, makes room for the next process's cache.
	- *Relocation registers* are temporary registers used for transferring user processes across memory. They store base-limit registers to track where the transferred memory originated.

Memory consists of a **system area** (reserved for the OS/Kernel) and a **user area** (for user programs). The system area includes a buffer zone, called the _transient area_, for additional memory needs.
## [[Memory Management Unit]]
The **Memory Management Unit (MMU)** is a hardware chip on RAM that allocates and deallocates memory. It acts as the device controller for RAM, and manages the memory operations between OS and physical memory.
### 1. Address Binding
Address binding is where variables in program are bound to physical addresses in memory. This can be done at any step along the compilation-execution process
- Variables in program: *Symbolic addresses*
- Addresses in object code: *Relocatable addresses*
- Addresses in executable: *Absolute addresses*
Compiler: Symbolic -> Relocatable
Linker/Loader: Relocatable -> Absolute

![[Pasted image 20241220181109.png]]

1. Compile-time binding: When variables are assigned absolute addresses after compile time, it's called absolute code. This requires the user process to always reside in a fixed location. 
	- If starting location is changed, the program has to be recompiled
2. Load time binding: When compiler generates reallocatable addresses. Here, final binding is delayed until load-time where absolute addresses are assigned.
	- If starting location is changed, the program has to be reloaded
3. Execution time binding: Allows a program to be moved during its execution between memory segments. Here, relocation registers (base registers in virtual memory) are used for binding. This is also called runtime allocation

If the binding occurs at **compile-time**, it is _static allocation_. If it occurs at **runtime**, it is _dynamic allocation_.
### 2. Address Space
The set of addresses in memory where the program resides/has access to is called address space.
- The addresses generated by the CPU are *logical addresses*. They reside in the *logical address space*
- The actual addresses in memory, i.e the ones loaded in the MMU are *physical addresses*. This is the *physical address space*
- In run-time address binding, the program is bound to virtual memory which is then allocated in runtime by the MMU to physical memory. Hence, logical addresses exist as *virtual addresses* and make up the *virtual address space*. 
	- There are no fixed(static) base and limit registers involved here, as the program is not bound to physical memory yet. These registers can be relocated. Hence, they are termed *relocation registers* which can move and be split across the memory
User programs never have direct access to physical address space. Any registers the program creates/deletes are with respect to the base address (and hence are always logical addresses). The MMU (in kernel mode) is responsible for mapping the logical to physical addresses.
Ex:
	Logical address: 0 to MAX (written to/controlled by program)
	Physical address: R to R+MAX (where R is a base address) (not under direct access of program)
![[Pasted image 20241221212342.png]]

### 3. Linking, Loading and Shared Libraries
Libraries can be loaded into the program statically or dynamically
- *Static linking*: Where library modules are combined by the loader into the program binary
- *Dynamic linking:* Library linking is postponed until execution. (used in glibc)
	- Libraries can be shared among multiple processes without creating multiple copies of it (hence *DLLs* are called *Shared libraries*)
	- These shared libraries are also updated centrally and all programs access up-to-date versions of libraries
- *Dynamic loading:* A technique of running programs larger than memory by dynamically loading-unloading instructions between memory and storage.
	- Only required functions/routines are loaded into memory when needed.
	- The relocatable linking loader is called to load a routine into memory from storage. It also checks whether the routine has been loaded in memory.

## Contiguous Memory Allocation
- When memory is allocated as a continuous band/range of registers
- Each process resides in a contiguous band of memory.
	1. *Simplicity*: Easy to implement with minimal overhead.
	2. *Faster Execution*: Direct access to memory blocks leads to quicker process execution.
	3. *Low Overhead*: Fewer pointers and metadata reduce management complexity.
	4. *Minimal Fragmentation:* Lower risk of small unusable gaps between allocations.
	5. *Efficient Access:* Sequential data access improves read/write performance.
	6. *Easier Control*: Simplifies monitoring and management of memory resources.
### 1. Memory Protection
- Preventing user processes from accessing memory that is not allocated to them.
	- Commonly implemented using base-limit registers
	- During dynamic memory allocation, relocation-limit registers are used
When a CPU generates a logical address for a process, the following steps occur:
1. The CPU generates a logical address.
2. *Memory Validation:* The memory management unit (MMU) checks if this logical address is less than the value in the limit register. If it exceeds this limit, an illegal memory access trap is triggered.
3. *Address Mapping:* If the logical address is valid, the MMU adds the value from the relocation register to the logical address to produce the corresponding physical address. 
	- Ex: if a logical address of 346 is generated, and the relocation register holds 100040, the physical address calculated would beÂ 100040+346=100386100040+346=100386.

- **Dynamic Storage Allocation Problem**: Finding a way to fit memory requests into free holes (blocks of empty memory):
    - _First Fit_: Allocates the first available hole large enough for the process.
    - _Best Fit_: Allocates the smallest hole that fits. Searches the entire list of holes.
    - _Worst Fit_: Allocates the largest hole that fits. Also searches the entire list.
**Fragmentation**: Allocated memory is scattered, causing inefficient use of memory.
- _Memory Compaction_ attempts to solve fragmentation by moving all holes to the end of memory and consolidating allocated memory into continuous blocks.

## Non-Contiguous Memory Allocation
Non-contiguous allocation assigns memory in fragments, spread across different locations in RAM. This method avoids fragmentation and supports dynamic memory needs.
**Segmentation** divides a process into logical segments based on functions. Each segment is stored contiguously, ensuring critical sections remain intact.
- A **segmentation table** tracks the base address and size of each segment using:
    - _STBR_ (Segment Table Base Register): Points to the table's start.
    - _STLR_ (Segment Table Limit Register): Indicates the number of segments.
If a segment is not in physical memory, the MMU uses an invalidation bit to flag its absence. When the CPU tries to access such a segment, an interrupt is generated (_segmentation fault_). The segment is then loaded into memory, and the segmentation table is updated.

This structured approach ensures efficient memory use and robust process management.